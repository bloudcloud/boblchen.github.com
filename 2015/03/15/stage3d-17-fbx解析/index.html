<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>stage3d_17_fbx解析 | Hello World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="…">
<meta property="og:type" content="article">
<meta property="og:title" content="stage3d_17_fbx解析">
<meta property="og:url" content="http://yoursite.com/2015/03/15/stage3d-17-fbx解析/">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="…">
<meta property="og:image" content="http://wonderffee.github.io/images/3d-coordinate-system/coordinate-system1.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="stage3d_17_fbx解析">
<meta name="twitter:description" content="…">

  
    <link rel="alternative" href="/atom.xml" title="Hello World" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hello World</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-stage3d-17-fbx解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/15/stage3d-17-fbx解析/" class="article-date">
  <time datetime="2015-03-15T05:53:47.000Z" itemprop="datePublished">Mar 15 2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      stage3d_17_fbx解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>…<br><a id="more"></a><br>…</p>
<h1 id="Fbx解析">Fbx解析</h1>
<p>以下均以该脚本为说明:<a href="https://github.com/BobLChen/flash3d-fbx-stage3d-python" target="_blank" rel="external">戳这里</a>。在stage3d中，由于一切都太低层，因此模型的格式也就成为了美术-&gt;程序的一道坑。现在也有很多通用格式，例如obj,3ds,dae等等。在做stage3d开发中，这些格式都不适合页游开发。原因其实很简单：</p>
<ul>
<li>文件采用文本格式，体积太大</li>
<li>任何语言对字符处理都比较慢，由于是as3，因此速度更加慢，在对文本内容进行解析时，占用时间非常长。</li>
<li>格式过于臃肿</li>
<li>不能支持骨骼动画</li>
</ul>
<p>因此我们需要拥有一套自己的格式。最好能够让stage3d能够拿到数据之后就直接使用，而不再进行任何处理。这样就需要我们在预先对模型数据进行一定的处理。这样就省掉了我们在运行期解析模型的过程。</p>
<h3 id="选择FBX的原因">选择FBX的原因</h3>
<ul>
<li>现在几乎所有的3d建模软件都支持FBX格式的导入导出。</li>
<li>FBX格式包含了所有的信息(FBX格式本身不会包含贴图，只存储路径)</li>
<li>有比较完善的SDK支持。<a href="http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=10775847" target="_blank" rel="external">戳这里</a></li>
</ul>
<h3 id="选择PythonSDK的原因">选择PythonSDK的原因</h3>
<ul>
<li>python语法简单，适合编写工具，保留源码，随用随改不需要进行编译，相对于C++可以少量代码实现功能</li>
<li>跨平台</li>
</ul>
<h3 id="如何安装">如何安装</h3>
<h4 id="Python安装">Python安装</h4>
<p>使用Python2.7版本。大家下载自己对应平台的Python安装包即可。<a href="https://www.python.org/downloads/" target="_blank" rel="external">戳这里</a>。下载安装完成之后需要配置环境变量。</p>
<ul>
<li>Windows:<a href="http://jingyan.baidu.com/article/48206aeafdcf2a216ad6b316.html" target="_blank" rel="external">戳这里</a>。如果链接失效，大家随便百度一下就明白。</li>
<li>Mac:应该是</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/Library/</span>Frameworks<span class="regexp">/Python.framework/</span>Versions<span class="regexp">/2.7/</span>bin<span class="regexp">/python</span></div></pre></td></tr></table></figure>

<p>这个路径下。大家需要看要一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/</span></div></pre></td></tr></table></figure>

<p>路径下面有没有python2.7。如果没有的话，需要建立一个软链接过去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s <span class="regexp">/Library/</span>Frameworks<span class="regexp">/Python.framework/</span>Versions<span class="regexp">/2.7/</span>bin<span class="regexp">/python /</span>usr<span class="regexp">/bin/</span>python2.<span class="number">7</span></div></pre></td></tr></table></figure>

<h4 id="FbxSDK安装">FbxSDK安装</h4>
<p>大家去下载FBX SDK 2015.1 Python.一定要下载这个版本，每个版本的SDK都有不同程度的BUG。并且API部分不同。所以防止坑爹务必下载对应的版本。下载完之后然后安装。<br>安装完成之后，找到FBX SDK 2014.1的安装路径，在里面找到lib文件夹，里面有对应python版本的文件夹。</p>
<ul>
<li>例:Windows路径:C:\Program Files\Autodesk\FBX\FBX Python SDK\2015.1\lib\Python27_x86</li>
<li>例:Mac路径:/Applications/Autodesk/FBX\ Python\ SDK/2015.1/lib/Python27</li>
</ul>
<p>然后将里面对应的三个文件”fbx.pyd”、”FbxCommon.py”、”fbxsip.pyd”拷贝到Python的安装目录/Lib/site-packages/文件夹里面。</p>
<ul>
<li>例:Windows:拷贝至:C:\Python27\Lib\site-packages\</li>
<li>例:Mac:拷贝至:/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/</li>
</ul>
<p>考完完成之后，安装就告一段落。</p>
<h2 id="使用python解析FBX">使用python解析FBX</h2>
<p>首先导入我们需要的库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from FbxCommon <span class="preprocessor"><span class="keyword">import</span> *</span></div><div class="line">from platform <span class="preprocessor"><span class="keyword">import</span> system</span></div><div class="line">from string <span class="preprocessor"><span class="keyword">import</span> count</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> logging</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> argparse</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> json</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> os</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> re</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> struct</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> sys</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> zlib</span></div></pre></td></tr></table></figure>

<p>然后编写main函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    </div><div class="line">    reload(sys)</div><div class="line">    sys.setdefaultencoding(<span class="string">'utf8'</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># log</span></div><div class="line">    logging.basicConfig(</div><div class="line">                        level    = logging.DEBUG,</div><div class="line">                        <span class="built_in">format</span>   = <span class="string">'%(asctime)s %(filename)s %(levelname)s %(message)s'</span>,</div><div class="line">                        datefmt  = <span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</div><div class="line">                        filename = <span class="string">'log.log'</span>,</div><div class="line">                        filemode = <span class="string">'w'</span>)</div><div class="line">    console = logging.StreamHandler(sys.<span class="keyword">stdout</span>)</div><div class="line">    console.setLevel(logging.INFO)</div><div class="line">    formatter = logging.Formatter(<span class="string">'%(name)-12s: %(levelname)-8s %(message)s'</span>)</div><div class="line">    console.setFormatter(formatter)</div><div class="line">    logging.getLogger(<span class="string">''</span>).addHandler(console)</div><div class="line">    <span class="comment"># end</span></div><div class="line">    </div><div class="line">    <span class="comment"># 解析参数</span></div><div class="line">    config = parseArgument()</div><div class="line">    fbxList = scanFbxFiles(config.path)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> <span class="keyword">item</span> <span class="operator">in</span> fbxList:</div><div class="line">        parseFBX(<span class="keyword">item</span>, config)</div><div class="line">        pass</div><div class="line">    </div><div class="line">    logging.info(<span class="string">"ʕ•̫͡•ʕ*̫͡*ʕ"</span>)</div><div class="line"></div><div class="line">    pass</div></pre></td></tr></table></figure>

<h3 id="解析参数">解析参数</h3>
<p>根据项目需要的不同，我们需求的模型数据也是不相同，例如有些模型可能需要法线，有些模型需要切线，有些模型可能只需要顶点即可。解析参数函数定义如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 解析命令行参数</span></div><div class="line">def parseArgument():</div><div class="line">    </div><div class="line">    logging.info(<span class="string">"parse arguments..."</span>)</div><div class="line">    </div><div class="line">    <span class="variable">parser =</span> argparse.ArgumentParser()</div><div class="line">    <span class="comment"># 解析法线</span></div><div class="line">    parser.add_argument(<span class="string">"-normal"</span>,  <span class="variable">help =</span> <span class="string">"parse normal"</span>,              <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 解析切线</span></div><div class="line">    parser.add_argument(<span class="string">"-tangent"</span>, <span class="variable">help =</span> <span class="string">"parse tangent"</span>,             <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 解析UV0</span></div><div class="line">    parser.add_argument(<span class="string">"-uv0"</span>,     <span class="variable">help =</span> <span class="string">"parse uv0"</span>,                 <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 解析UV1</span></div><div class="line">    parser.add_argument(<span class="string">"-uv1"</span>,     <span class="variable">help =</span> <span class="string">"parse uv1"</span>,                 <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 解析动画</span></div><div class="line">    parser.add_argument(<span class="string">"-anim"</span>,    <span class="variable">help =</span> <span class="string">"parse animation"</span>,           <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 使用geometry坐标</span></div><div class="line">    parser.add_argument(<span class="string">"-geometry"</span>, <span class="variable">help =</span> <span class="string">"geometry transform"</span>,        <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 使用全局坐标</span></div><div class="line">    parser.add_argument(<span class="string">"-world"</span>,   <span class="variable">help =</span> <span class="string">"world Transofrm"</span>,           <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 指定Fbx文件路径</span></div><div class="line">    parser.add_argument(<span class="string">"-path"</span>,    <span class="variable">help =</span> <span class="string">"fbx file path  "</span>,           <span class="variable">action =</span> <span class="string">"store"</span>,           <span class="variable">default =</span> <span class="string">""</span>)</div><div class="line">    <span class="comment"># 使用四元数方式</span></div><div class="line">    parser.add_argument(<span class="string">"-quat"</span>,    <span class="variable">help =</span> <span class="string">"quat with anima"</span>,           <span class="variable">action =</span> <span class="string">"store_true"</span>,      <span class="variable">default =</span> False)</div><div class="line">    <span class="comment"># 使用四元数时，最大骨骼数</span></div><div class="line">    parser.add_argument(<span class="string">"-max_quat"</span>,<span class="variable">help =</span> <span class="string">"bone num with quat"</span>,        <span class="variable">action =</span> <span class="string">"store"</span>,           <span class="variable">default =</span> <span class="number">56</span>)</div><div class="line">    <span class="comment"># 使用矩阵时，最大骨骼数</span></div><div class="line">    parser.add_argument(<span class="string">"-max_m34"</span>, <span class="variable">help =</span> <span class="string">"bone num with m34"</span>,         <span class="variable">action =</span> <span class="string">"store"</span>,           <span class="variable">default =</span> <span class="number">36</span>)</div><div class="line">    <span class="comment"># 挂节点</span></div><div class="line">    parser.add_argument(<span class="string">"-mount"</span>,  <span class="variable">help =</span> <span class="string">"mount bone, split by ','"</span>,   <span class="variable">action =</span> <span class="string">"store"</span>,  <span class="variable">default =</span> <span class="string">"Bone001"</span>)</div><div class="line">    </div><div class="line">    <span class="variable">option =</span> parser.parse_args()</div><div class="line">    option.<span class="variable">mount =</span> option.mount.split(<span class="string">","</span>)</div><div class="line">    </div><div class="line">    return option</div><div class="line">    pass</div></pre></td></tr></table></figure>

<p>参数解析完成之后，我们就可以在控制台调用python时输入各种参数。例如获取帮助信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Neil@^_^:~/python$ python FbxParser.py -h</div><div class="line">root        : INFO     parse arguments...</div><div class="line">usage: FbxParser.py [-h] [-normal] [-tangent] [-uv0] [-uv1] [-anim] [-geomtry]</div><div class="line">                    [-world] [-path PATH] [-quat] [-max_quat MAX_QUAT]</div><div class="line">                    [-max_m34 MAX_M34] [-mount MOUNT]</div><div class="line"></div><div class="line">optional arguments:</div><div class="line">  -<span class="ruby">h, --help          show this help message <span class="keyword">and</span> exit</span></div><div class="line">  -<span class="ruby">normal             parse normal</span></div><div class="line">  -<span class="ruby">tangent            parse tangent</span></div><div class="line">  -<span class="ruby">uv<span class="number">0</span>                parse uv<span class="number">0</span></span></div><div class="line">  -<span class="ruby">uv1                parse uv1</span></div><div class="line">  -<span class="ruby">anim               parse animation</span></div><div class="line">  -<span class="ruby">geomtry            geometry transform</span></div><div class="line">  -<span class="ruby">world              world <span class="constant">Transofrm</span></span></div><div class="line">  -<span class="ruby">path <span class="constant">PATH</span>          fbx file path</span></div><div class="line">  -<span class="ruby">quat               quat with anima</span></div><div class="line">  -<span class="ruby">max_quat <span class="constant">MAX_QUAT</span>  bone num with quat</span></div><div class="line">  -<span class="ruby">max_m34 <span class="constant">MAX_M34</span>    bone num with m34</span></div><div class="line">  -<span class="ruby">mount <span class="constant">MOUNT</span>        mount bone, split by <span class="string">','</span></span></div><div class="line">Neil@^_^:~/python$</div></pre></td></tr></table></figure>

<p>一般来说，在参数中”-“为简写，”—“为详细指令。这里我就直接使用”-“来描述了。然后在控制台中，我们可以通过执行命令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> FbxParser.<span class="keyword">py</span> -uv0 -uv1 -anim</div></pre></td></tr></table></figure>

<p>来告诉python脚本解析uv0,uv1以及动画数据。那么在脚本中，我们就可以得到config.uv0、config.uv1、config.anim来获取对应的参数数据。</p>
<h3 id="获取Fbx文件路径">获取Fbx文件路径</h3>
<p>如果我们传入的参数有路径，则直接解析该路径的fbx文件，如果没有我们就扫描当前目录以及子目录的所有fbx文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 扫描Fbx文件</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanFbxFiles</span><span class="params">(args)</span>:</span></div><div class="line">    <span class="comment"># 拼接fbx文件</span></div><div class="line">    fbxList = []</div><div class="line">    <span class="keyword">if</span> os.path.isfile(args):</div><div class="line">        fbxList.append(args)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        logging.info(<span class="string">"scane current directory:%s"</span> % os.getcwd())</div><div class="line">        <span class="keyword">for</span> parentDir, _, fileNames <span class="keyword">in</span> os.walk(os.getcwd()):</div><div class="line">            <span class="keyword">for</span> fileName <span class="keyword">in</span> fileNames:</div><div class="line">                <span class="keyword">if</span> fileName.endswith(<span class="string">'FBX'</span>) <span class="keyword">or</span> fileName.endswith(<span class="string">'fbx'</span>):</div><div class="line">                    filePath = os.path.join(parentDir, fileName)</div><div class="line">                    fbxList.append(str(filePath))</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">pass</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># 打印</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> fbxList:</div><div class="line">        logging.info(<span class="string">"find fbx file: %s"</span> % item)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">return</span> fbxList</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<p>获取到Fbx文件路径之后，我们就可以开始正式的进行Fbx解析。</p>
<h3 id="初始化SDK载入FBX">初始化SDK载入FBX</h3>
<p>InitializeSdkObjects函数是由Fbx SDK提供的，通过这个函数我们获取到SDKManager和Scene。然后通过LoadScene载入Fbx文件。载入成功之后我们需要检测一下是否载入成功。只有载入成功之后我们才进行后续的操作。当载入成功之后，我们对场景的所有模型进行三角化操作。因为在很多工具导出的Fbx模型里面会包含四边形、五边形甚至多边形。我们为了方便处理，统统三角化，并且在stage3d中，我们也只能使用三角形。三角化之后，我们需要设置Fbx的坐标系。在游戏中我们使用的左手坐标系:<img src="http://wonderffee.github.io/images/3d-coordinate-system/coordinate-system1.jpg" class="[class names]"><br>但是不同的工具导出的Fbx模型的坐标系也是不同的。例如3dsMax使用的是X轴向右，Z向上，Y向前的坐标。为了方便后面的数据转换，我们先统一一下坐标系。但是这个坐标系并不改变模型的本身数据结果，只是改变了Root节点的变化数据而已。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析FBX文件</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseFBX</span><span class="params">(fbxfile, config)</span>:</span></div><div class="line">    logging.info(<span class="string">"parse fbx file:%s"</span> % (fbxfile))</div><div class="line">    <span class="comment"># 初始化SDKManager以及Scene</span></div><div class="line">    sdkManager, scene = InitializeSdkObjects()</div><div class="line">    <span class="comment"># 加载FBX</span></div><div class="line">    content = LoadScene(sdkManager, scene, fbxfile)</div><div class="line">    <span class="comment"># fbx文件装载失败</span></div><div class="line">    <span class="keyword">if</span> content == <span class="keyword">False</span>:</div><div class="line">        logging.info(<span class="string">"Fbx load failed:%s"</span> % fbxfile)</div><div class="line">        sdkManager.Destroy()</div><div class="line">        <span class="keyword">return</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># 对场景三角化</span></div><div class="line">    converter = FbxGeometryConverter(sdkManager)</div><div class="line">    converter.Triangulate(scene, <span class="keyword">True</span>)</div><div class="line">    axisSystem = FbxAxisSystem.OpenGL</div><div class="line">    axisSystem.ConvertScene(scene)</div><div class="line">    </div><div class="line">    <span class="comment"># 开始解析fbx</span></div><div class="line">    scene3d = Scene3D()</div><div class="line">    scene3d.fbxfile = fbxfile</div><div class="line">    <span class="comment"># 解析相机</span></div><div class="line">    scene3d.cameras = parseCameras(sdkManager, scene, fbxfile)</div><div class="line">    <span class="comment"># 解析模型</span></div><div class="line">    scene3d.meshes  = parseMeshes(sdkManager, scene, fbxfile)</div><div class="line">    <span class="comment"># 写场景配置</span></div><div class="line">    writeSceneConfig(scene3d)</div><div class="line">    </div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<h3 id="遍历Fbx模型">遍历Fbx模型</h3>
<p>通过scene.GetSrcObjectCount(FbxMesh.ClassId)可以获取到对应FbxMesh类型的数量。scene.GetSrcObject(FbxMesh.ClassId, i)可以获取对应的FbxMesh对象。FbxMesh就是模型，里面包含了模型的所有数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析所有的模型</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseMeshes</span><span class="params">(sdkManager, scene, filepath)</span>:</span></div><div class="line">    logging.info(<span class="string">"\tparse meshes..."</span>)</div><div class="line">    count = scene.GetSrcObjectCount(FbxMesh.ClassId)</div><div class="line">    logging.info(<span class="string">"\tmesh num:%d"</span> % (count))</div><div class="line">    meshes = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">        fbxMesh = scene.GetSrcObject(FbxMesh.ClassId, i)</div><div class="line">        mesh = Mesh()</div><div class="line">        mesh.initWithFbxMesh(fbxMesh, sdkManager, scene, filepath)</div><div class="line">        meshes.append(mesh)</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">    <span class="keyword">return</span> meshes</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<h4 id="定义Matrix3D数据类型">定义Matrix3D数据类型</h4>
<p>在FBX SDK虽然提供了Matrix3D，但是有部分API并没有提供，在后面的变换中，我们需要用到。因此我们需要简单封装一个Matrix3D。有一点需要注意，FbxSdk使用的是Opengl那种列行式矩阵。而stage3d中使用的是行列式。即在stage3d中，从A变换到B为:AB。但是在Opengl(FBX SDK)中为:BA。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Matrix3D矩阵，通过FbxAMatrix初始化</span></div><div class="line"><span class="comment"># 使用主列矩阵，矩阵是反着的。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix3D</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""docstring for Matrix3D"""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mt)</span>:</span></div><div class="line">        super(Matrix3D, self).__init__()</div><div class="line">        self.rawData = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">            row = mt.GetRow(i)</div><div class="line">            self.rawData[i * <span class="number">4</span> + <span class="number">0</span>] = row[<span class="number">0</span>]</div><div class="line">            self.rawData[i * <span class="number">4</span> + <span class="number">1</span>] = row[<span class="number">1</span>]</div><div class="line">            self.rawData[i * <span class="number">4</span> + <span class="number">2</span>] = row[<span class="number">2</span>]</div><div class="line">            self.rawData[i * <span class="number">4</span> + <span class="number">3</span>] = row[<span class="number">3</span>]</div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="comment"># 获取一列</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRaw</span><span class="params">(self, raw)</span>:</span></div><div class="line">        vec = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</div><div class="line">        vec[<span class="number">0</span>] = self.rawData[raw + <span class="number">0</span>];</div><div class="line">        vec[<span class="number">1</span>] = self.rawData[raw + <span class="number">4</span>];</div><div class="line">        vec[<span class="number">2</span>] = self.rawData[raw + <span class="number">8</span>];</div><div class="line">        vec[<span class="number">3</span>] = self.rawData[raw + <span class="number">12</span>];</div><div class="line">        <span class="keyword">return</span> vec</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="comment"># 获取一行</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getColumn</span><span class="params">(self, column)</span>:</span></div><div class="line">        vec = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</div><div class="line">        vec[<span class="number">0</span>] = self.rawData[column * <span class="number">4</span> + <span class="number">0</span>]</div><div class="line">        vec[<span class="number">1</span>] = self.rawData[column * <span class="number">4</span> + <span class="number">1</span>]</div><div class="line">        vec[<span class="number">2</span>] = self.rawData[column * <span class="number">4</span> + <span class="number">2</span>]</div><div class="line">        vec[<span class="number">3</span>] = self.rawData[column * <span class="number">4</span> + <span class="number">3</span>]</div><div class="line">        <span class="keyword">return</span> vec</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line">    </div><div class="line">    <span class="comment"># deltaTransform</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deltaTransformVector</span><span class="params">(self, vec)</span>:</span></div><div class="line">        right = [self.rawData[<span class="number">0</span>], self.rawData[<span class="number">4</span>], self.rawData[<span class="number">8</span>]]</div><div class="line">        up    = [self.rawData[<span class="number">1</span>], self.rawData[<span class="number">5</span>], self.rawData[<span class="number">9</span>]]</div><div class="line">        ddir  = [self.rawData[<span class="number">2</span>], self.rawData[<span class="number">6</span>], self.rawData[<span class="number">10</span>]]</div><div class="line">        out   = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</div><div class="line">        out[<span class="number">0</span>] = vec[<span class="number">0</span>] * right[<span class="number">0</span>] + vec[<span class="number">1</span>] * right[<span class="number">1</span>] + vec[<span class="number">2</span>] * right[<span class="number">2</span>]</div><div class="line">        out[<span class="number">1</span>] = vec[<span class="number">0</span>] * up[<span class="number">0</span>]    + vec[<span class="number">1</span>] * up[<span class="number">1</span>]    + vec[<span class="number">2</span>] * up[<span class="number">2</span>]</div><div class="line">        out[<span class="number">2</span>] = vec[<span class="number">0</span>] * ddir[<span class="number">0</span>]  + vec[<span class="number">1</span>] * ddir[<span class="number">1</span>]  + vec[<span class="number">2</span>] * ddir[<span class="number">2</span>]</div><div class="line">        <span class="keyword">return</span> out</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="comment"># transform</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transformVector</span><span class="params">(self, vec)</span>:</span></div><div class="line">        right = [self.rawData[<span class="number">0</span>],  self.rawData[<span class="number">4</span>],  self.rawData[<span class="number">8</span>]]</div><div class="line">        up    = [self.rawData[<span class="number">1</span>],  self.rawData[<span class="number">5</span>],  self.rawData[<span class="number">9</span>]]</div><div class="line">        ddir  = [self.rawData[<span class="number">2</span>],  self.rawData[<span class="number">6</span>],  self.rawData[<span class="number">10</span>]]</div><div class="line">        out   = [self.rawData[<span class="number">12</span>], self.rawData[<span class="number">13</span>], self.rawData[<span class="number">14</span>]]</div><div class="line">        out[<span class="number">0</span>] = out[<span class="number">0</span>] + vec[<span class="number">0</span>] * right[<span class="number">0</span>] + vec[<span class="number">1</span>] * right[<span class="number">1</span>] + vec[<span class="number">2</span>] * right[<span class="number">2</span>]</div><div class="line">        out[<span class="number">1</span>] = out[<span class="number">1</span>] + vec[<span class="number">0</span>] * up[<span class="number">0</span>]    + vec[<span class="number">1</span>] * up[<span class="number">1</span>]    + vec[<span class="number">2</span>] * up[<span class="number">2</span>]</div><div class="line">        out[<span class="number">2</span>] = out[<span class="number">2</span>] + vec[<span class="number">0</span>] * ddir[<span class="number">0</span>]  + vec[<span class="number">1</span>] * ddir[<span class="number">1</span>]  + vec[<span class="number">2</span>] * ddir[<span class="number">2</span>]</div><div class="line">        <span class="keyword">return</span> out</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>

<h4 id="实用函数的封装">实用函数的封装</h4>
<p>其中GeometryTransform用于获取网格的变换数据。getMatrix3DBytes则是用于将FBXAMatrix数据转换为二进制。getQuatBytesFromAMatrix函数用于从FBXAMatrix中获取对应的四元数数据。parseFilepath用于获取Fbx的文件目录。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取GeometryTransform</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetGeometryTransform</span><span class="params">(node)</span>:</span></div><div class="line">    t = node.GetGeometricTranslation(FbxNode.eSourcePivot)</div><div class="line">    r = node.GetGeometricRotation(FbxNode.eSourcePivot)</div><div class="line">    s = node.GetGeometricScaling(FbxNode.eSourcePivot)</div><div class="line">    <span class="keyword">return</span> FbxAMatrix(t, r, s)</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line"></div><div class="line"><span class="comment"># 生成FbxAMatrix数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMatrix3DBytes</span><span class="params">(fbxAMatrix)</span>:</span></div><div class="line">    matrix = Matrix3D(fbxAMatrix)</div><div class="line">    data = <span class="string">b''</span></div><div class="line">    <span class="comment"># 丢弃最后一列数据</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">        raw = matrix.getRaw(i)</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(raw)):</div><div class="line">            data += struct.pack(<span class="string">'&lt;f'</span>, raw[j])</div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">return</span> data</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line"></div><div class="line"><span class="comment"># 生成Quat数据</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getQuatBytesFromAMatrix</span><span class="params">(fbxAMatrix)</span>:</span></div><div class="line">    data = <span class="string">b''</span></div><div class="line">    t = fbxAMatrix.GetT()</div><div class="line">    q = fbxAMatrix.GetQ()</div><div class="line">    data += struct.pack(<span class="string">'&lt;ffff'</span>, t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], <span class="number">0</span>)</div><div class="line">    data += struct.pack(<span class="string">'&lt;ffff'</span>, q[<span class="number">0</span>], q[<span class="number">1</span>], q[<span class="number">2</span>], q[<span class="number">3</span>])</div><div class="line">    <span class="keyword">return</span> data</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line"></div><div class="line"><span class="comment"># 打印矩阵</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printFBXAMatrix</span><span class="params">(sstr, transform)</span>:</span></div><div class="line">    logging.info(<span class="string">"%s TX:%f\tTY:%f\tTZ:%f"</span> % (sstr, transform.GetT()[<span class="number">0</span>], transform.GetT()[<span class="number">1</span>], transform.GetT()[<span class="number">2</span>]))</div><div class="line">    logging.info(<span class="string">"%s RX:%f\tRY:%f\tRZ:%f"</span> % (sstr, transform.GetR()[<span class="number">0</span>], transform.GetR()[<span class="number">1</span>], transform.GetR()[<span class="number">2</span>]))</div><div class="line">    logging.info(<span class="string">"%s SX:%f\tSY:%f\tSZ:%f"</span> % (sstr, transform.GetS()[<span class="number">0</span>], transform.GetS()[<span class="number">1</span>], transform.GetS()[<span class="number">2</span>]))</div><div class="line">    logging.info(<span class="string">"%s RawData:%s"</span> % (sstr, str(Matrix3D(transform).rawData)))</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line"></div><div class="line"><span class="comment"># 解析FBX文件目录</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseFilepath</span><span class="params">(fbxfile)</span>:</span></div><div class="line">    filepath = re.compile(<span class="string">"[\\\/]"</span>).split(fbxfile)[<span class="number">0</span>:-<span class="number">1</span>]</div><div class="line">    filepath.append(<span class="string">""</span>)</div><div class="line">    <span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:</div><div class="line">        filepath = <span class="string">"\\"</span>.join(filepath)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        filepath = <span class="string">'/'</span>.join(filepath)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="keyword">return</span> filepath</div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<h3 id="骨骼节点封装">骨骼节点封装</h3>
<p>在解析过程中，我们会对骨骼动画进行解析，为了方便我们存取以后后面的切割，我们需要简单定义一下骨骼节点的数据类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 骨骼节点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkeletonJoint</span><span class="params">(object)</span>:</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(SkeletonJoint, self).__init__()</div><div class="line">        self.node           = <span class="keyword">None</span>          <span class="comment"># 骨骼Node</span></div><div class="line">        self.name           = <span class="keyword">None</span>          <span class="comment"># 骨骼名称</span></div><div class="line">        self.index          = -<span class="number">1</span>            <span class="comment"># 骨骼索引</span></div><div class="line">        self.parentIndex    = -<span class="number">1</span>            <span class="comment"># 父级骨骼索引</span></div><div class="line">        self.cluster        = <span class="keyword">None</span>          <span class="comment"># 骨骼</span></div><div class="line">        self.linkTransform  = <span class="keyword">None</span>          <span class="comment"># link Transform</span></div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line">    </div><div class="line">    <span class="comment"># 通过cluster初始化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initWithCluster</span><span class="params">(self, cluster)</span>:</span></div><div class="line">        self.node = cluster.GetLink()</div><div class="line">        self.name = str(self.node.GetName())</div><div class="line">        self.cluster = cluster</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line">    </div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end class</span></div></pre></td></tr></table></figure>

<h3 id="Mesh数据封装">Mesh数据封装</h3>
<p>我们遍历Scene场景，获取到FBXMesh数据。但是我们需要对这个FBXMesh进行再次转换。以得到我们适用的数据。其中Mesh的数据格式如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># 模型</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span>(<span class="title">object</span>):</span></div><div class="line">    <span class="string">""</span><span class="string">"docstring for Mesh"</span><span class="string">""</span></div><div class="line">    def __init__(<span class="variable">self</span>):</div><div class="line">        <span class="variable">super</span>(Mesh, <span class="variable">self</span>).__init__()</div><div class="line">        <span class="variable">self</span>.fbxMesh            = None<span class="preprocessor">          # FbxMesh</span></div><div class="line">        <span class="variable">self</span>.sdkManager         = None<span class="preprocessor">          # FbxSdk</span></div><div class="line">        <span class="variable">self</span>.scene              = None<span class="preprocessor">          # FbxScene</span></div><div class="line">        <span class="variable">self</span>.fbxFilePath        = None<span class="preprocessor">          # Fbx文件路径</span></div><div class="line">        <span class="variable">self</span>.name               = None<span class="preprocessor">          # 模型名称</span></div><div class="line">        <span class="variable">self</span>.skeleton           = <span class="literal">False</span><span class="preprocessor">         # 是否为骨骼模型</span></div><div class="line">        <span class="variable">self</span>.transform          = None<span class="preprocessor">          # transform</span></div><div class="line">        <span class="variable">self</span>.geometryTransform  = None<span class="preprocessor">          # geometry矩阵</span></div><div class="line">        <span class="variable">self</span>.axisTransform      = None<span class="preprocessor">          # 坐标系矩阵</span></div><div class="line">        <span class="variable">self</span>.invAxisTransform   = None<span class="preprocessor">          # 坐标系逆矩阵</span></div><div class="line">        <span class="variable">self</span>.vertices           = []<span class="preprocessor">            # 顶点</span></div><div class="line">        <span class="variable">self</span>.uvs0               = []<span class="preprocessor">            # UV0</span></div><div class="line">        <span class="variable">self</span>.uvs1               = []<span class="preprocessor">            # UV1,可能为烘焙贴图UV</span></div><div class="line">        <span class="variable">self</span>.normals            = []<span class="preprocessor">            # 法线</span></div><div class="line">        <span class="variable">self</span>.tangents           = []<span class="preprocessor">            # 切线</span></div><div class="line">        <span class="variable">self</span>.weightsAndIndices  = []<span class="preprocessor">            # 权重以及索引</span></div><div class="line">        <span class="variable">self</span>.bounds             = LObject()<span class="preprocessor">     # 包围盒</span></div><div class="line">        <span class="variable">self</span>.anims              = []<span class="preprocessor">            # 动画|如果为骨骼模型，那么保存骨骼数据，否则就保存帧Transform数据</span></div><div class="line">        <span class="variable">self</span>.verticesIndices    = []<span class="preprocessor">            # 顶点索引</span></div><div class="line">        <span class="variable">self</span>.uvIndices          = []<span class="preprocessor">            # uv索引</span></div><div class="line">        <span class="variable">self</span>.joints             = []<span class="preprocessor">            # 骨骼列表</span></div><div class="line">        <span class="variable">self</span>.skeletonIndices    = {}<span class="preprocessor">            # 顶点索引，骨骼对应的顶点索引。</span></div><div class="line">        <span class="variable">self</span>.skeletonWeights    = {}<span class="preprocessor">            # 骨骼权重，骨骼对应的顶点权重。</span></div><div class="line">        <span class="variable">self</span>.meshBytes          = None<span class="preprocessor">          # Mesh数据</span></div><div class="line">        <span class="variable">self</span>.animBytes          = None<span class="preprocessor">          # 动作数据</span></div><div class="line">        <span class="variable">self</span>.meshFileName       = None<span class="preprocessor">          # Mesh文件名</span></div><div class="line">        <span class="variable">self</span>.animFileName       = None<span class="preprocessor">          # Anim文件名</span></div><div class="line">        <span class="variable">self</span>.bounds.<span class="built_in">min</span>         = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]<span class="preprocessor">     # min</span></div><div class="line">        <span class="variable">self</span>.bounds.<span class="built_in">max</span>         = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]<span class="preprocessor">     # max</span></div><div class="line">        <span class="variable">self</span>.geometries         = []<span class="preprocessor">            # sub geometry</span></div><div class="line">        <span class="variable">self</span>.material           = None<span class="preprocessor">          # 材质</span></div><div class="line">        <span class="variable">self</span>.mounts             = {}<span class="preprocessor">            # 挂接点</span></div><div class="line">        </div><div class="line">        pass<span class="preprocessor"> #<span class="keyword">end</span> func</span></div></pre></td></tr></table></figure>

<h3 id="FBXMesh的解析">FBXMesh的解析</h3>
<p>在前面def parseMeshes(sdkManager, scene, filepath)函数中，我们获取到了FBXMesh模型。然后我们初始化一个Mesh，通过Mesh.initWithFbxMesh方法来初始化Mesh并且解析FBXMesh。</p>
<ul>
<li>首先我们需要获取到FbxMesh的变换数据。包括:Geometry、Local、World。在获取的同时我们需要对我们获取到的数据进行转换。因为轴向不同，如果我们不经过任何转换，那么我们获取到的模型不仅是朝向、位置不同，而且被Flip掉了。大家可以随便找个图片预览工具看一下Flip的效果。在3d中，Flip影响更为严重。直接导致为左手变为右手，右手变为左手。这种情况不是简单的旋转就可以完成的。我们需要设置缩放(-1, 1, 1)来对模型再次Flip一下。之前提到，FBX使用的是Opengl的列行式矩阵。因此我们最终的变换矩阵为:AXIS_FLIP_L <em> xxx </em> yyy。代码如下:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># 解析矩阵</span></div><div class="line">def parseTransform(<span class="variable">self</span>):</div><div class="line">    logging.info(<span class="string">"\tparse transform..."</span>)</div><div class="line">    <span class="variable">self</span>.geometryTransform  = GetGeometryTransform(<span class="variable">self</span>.fbxMesh.GetNode())<span class="preprocessor"></span></div><div class="line">    # 当geometry启用时，world将会失效</div><div class="line">    <span class="keyword">if</span> config.geometry:</div><div class="line">        <span class="variable">self</span>.axisTransform = AXIS_FLIP_L * <span class="variable">self</span>.geometryTransform</div><div class="line">        pass</div><div class="line">    elif config.world:</div><div class="line">        <span class="variable">self</span>.axisTransform = AXIS_FLIP_L * <span class="variable">self</span>.fbxMesh.GetNode().EvaluateGlobalTransform() * <span class="variable">self</span>.geometryTransform</div><div class="line">        pass</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="variable">self</span>.axisTransform = AXIS_FLIP_L * <span class="variable">self</span>.fbxMesh.GetNode().EvaluateLocalTransform() * <span class="variable">self</span>.geometryTransform</div><div class="line">        pass<span class="preprocessor"></span></div><div class="line">    # invert axis transform</div><div class="line">    <span class="variable">self</span>.invAxisTransform = FbxAMatrix(<span class="variable">self</span>.axisTransform)</div><div class="line">    <span class="variable">self</span>.invAxisTransform = <span class="variable">self</span>.invAxisTransform.Inverse()<span class="preprocessor"></span></div><div class="line">    # 启用geometry</div><div class="line">    <span class="keyword">if</span> config.geometry:</div><div class="line">        <span class="variable">self</span>.transform = AXIS_FLIP_L * <span class="variable">self</span>.fbxMesh.GetNode().EvaluateGlobalTransform() * <span class="variable">self</span>.geometryTransform * <span class="variable">self</span>.invAxisTransform</div><div class="line">        pass</div><div class="line">    elif config.world:</div><div class="line">        <span class="variable">self</span>.transform = FbxAMatrix()</div><div class="line">        pass</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="variable">self</span>.transform = AXIS_FLIP_L * <span class="variable">self</span>.fbxMesh.GetNode().EvaluateGlobalTransform() * <span class="variable">self</span>.geometryTransform * <span class="variable">self</span>.invAxisTransform</div><div class="line">        pass</div><div class="line">    </div><div class="line">    printFBXAMatrix(<span class="string">"\tTransform Matrix:"</span>, <span class="variable">self</span>.transform)</div><div class="line">    </div><div class="line">    pass<span class="preprocessor"> # <span class="keyword">end</span> fun</span></div></pre></td></tr></table></figure>

<p>由于美术在制作模型时，姿势各不相同。有些可能是建好模型，然后在摆位置，有些可能直接在该位置直接建模。因此我们拿到的模型变换数据有三个。根据需求我们要适当保留其中的数据。例如：一个模型，如果我们想要在程序中摆放它的位置，那么我们就需要使用local数据，在程序中进行对它进行摆放。如果我们在程序中不想摆放模型的位置，并且希望模型直接出现在指定位置，那么我们就需要使用world数据等等。。。</p>
<h3 id="解析索引">解析索引</h3>
<p>FBX文件为了尽可能的减少数据。对于顶点、UV、法线都单独使用了一套索引数据。同样在obj文件中我们也会发现对于的数据都有单独的一套索引。然后我们需要在程序中根据索引获取对应的数据，组装到一起。这样的最终结果就是上传到GPU的数据其实是顺序的。即:012, 123, 234等等。这样在stage3d中索引其实毫无意义。除非我们顶点、uv、法线都是使用的同一套索引，并且确实保证了数据不重复。但是问题来了，由于相同顶点UV不同，法线不同，导致最终我们在程序中只能使用完整的数据。索引变得其实没有意义。我决定放弃在as3中重建顶点，uv，法线数据。直接使用以及构建好的数据，这样我们就省掉了在as3中解析的过程。但是会增加我们的模型文件体积。索引解析如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析索引</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseIndices</span><span class="params">(self)</span>:</span></div><div class="line">    logging.info(<span class="string">"\tparse indices..."</span>)</div><div class="line">    count = self.fbxMesh.GetPolygonCount()</div><div class="line">    logging.info(<span class="string">"\ttriangle num:%d"</span> % (count))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">            <span class="comment"># 顶点索引</span></div><div class="line">            vertIdx = self.fbxMesh.GetPolygonVertex(i, j)</div><div class="line">            self.verticesIndices.append(vertIdx)</div><div class="line">            <span class="comment"># uv索引</span></div><div class="line">            uvIdx = self.fbxMesh.GetTextureUVIndex(i, j)</div><div class="line">            self.uvIndices.append(uvIdx)</div><div class="line">            <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<p>这个过程我们只是获取到FBXMesh的索引数据，并没有根据索引建立数据。</p>
<h3 id="解析顶点">解析顶点</h3>
<p>解析完索引之后，我们就可以对顶点进行解析。在顶点的解析过程中，我们就会对顶点进行翻转，并且重构顶点的数据。在Fbx中，顶点以控制点的形式存在。self.fbxMesh.GetControlPointsCount()用于获取控制点的数量。self.fbxMesh.GetControlPoints()用于获取控制点的数据。我们通过之前的索引来从控制点中获取到对于三角形的三个顶点数据。获取完成之后，遍历新的顶点数据，进行转换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># 解析顶点</div><div class="line">def parseVertices(<span class="keyword">self</span>):</div><div class="line">    logging.info(<span class="string">"\tparse vertex..."</span>)</div><div class="line">    <span class="built_in">count</span> = <span class="keyword">self</span>.fbxMesh.<span class="type">GetControlPointsCount</span>()</div><div class="line">    points= <span class="keyword">self</span>.fbxMesh.<span class="type">GetControlPoints</span>()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">count</span>):</div><div class="line">        vert = points[i]</div><div class="line">        <span class="keyword">self</span>.vertices.append(vert)</div><div class="line">        pass # end <span class="keyword">for</span></div><div class="line">    # 组织顶点数据</div><div class="line">    vertices = []</div><div class="line">    <span class="built_in">count</span> = len(<span class="keyword">self</span>.verticesIndices)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">count</span>):</div><div class="line">        idx = <span class="keyword">self</span>.verticesIndices[i]</div><div class="line">        vert= <span class="keyword">self</span>.vertices[idx]</div><div class="line">        vertices.append(vert)</div><div class="line">        pass</div><div class="line">    <span class="keyword">self</span>.vertices = vertices</div><div class="line">    logging.info(<span class="string">"\tvetex num:%d"</span> % (len(<span class="keyword">self</span>.vertices)))</div><div class="line">    # 对顶点坐标轴转换</div><div class="line">    <span class="built_in">count</span> = len(<span class="keyword">self</span>.vertices)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">count</span>):</div><div class="line">        vert = <span class="keyword">self</span>.vertices[i]</div><div class="line">        vert = <span class="keyword">self</span>.axisTransform.<span class="type">MultT</span>(vert)</div><div class="line">        <span class="keyword">self</span>.vertices[i] = [vert[<span class="number">0</span>], vert[<span class="number">1</span>], vert[<span class="number">2</span>]]</div><div class="line">        pass # end <span class="keyword">for</span></div><div class="line">    # 重构顶点索引顺序</div><div class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> / <span class="number">3</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">count</span>):</div><div class="line">        v0 = <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">0</span>]</div><div class="line">        v1 = <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">1</span>]</div><div class="line">        v2 = <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">2</span>]</div><div class="line">        <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">0</span>] = v2</div><div class="line">        <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">1</span>] = v1</div><div class="line">        <span class="keyword">self</span>.vertices[i * <span class="number">3</span> + <span class="number">2</span>] = v0</div><div class="line">        pass # end <span class="keyword">for</span></div><div class="line">    # 解析包围盒</div><div class="line">    <span class="keyword">self</span>.parseBounds()</div><div class="line">    pass # end <span class="func"><span class="keyword">func</span></span></div></pre></td></tr></table></figure>

<p>这里有一点需要特别注意。我们对顶点数据进行FLIP了之后，顶点的索引顺序发生了改变。前面提到，stage3d使用顺时针方式，当顶点索引发生了变化之后，我们对模型进行了裁剪，模型的显示就会不正常。因此我们需要将索引也变换一下。因此在这里我们只需要对解析好的三角形顶点数据交换一下位置即可。</p>
<h3 id="解析uv0">解析uv0</h3>
<p>根据传入的参数，控制是否需要解析uv数据。一般第0层的uv为模型的贴图uv。第1层可能为lightmap等等其它的数据。如果项目有需求多套数据的时候，程序需要和美术约定好uv的和层级的对应关系。同样我们根据uv的索引来获取每个三角形对应的三个顶点的uv数据。在fbx中uv的数据存储分为了很多种格式。这里我不再详细叙述。获取到uv数据之后，由于我们的flip操作，我们仍然需要交换一下uv的顺序。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析UV0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseUV0</span><span class="params">(self)</span>:</span></div><div class="line">    layerCount = self.fbxMesh.GetLayerCount()</div><div class="line">    <span class="comment"># 解析UV0</span></div><div class="line">    <span class="keyword">if</span> layerCount &gt;= <span class="number">1</span>:</div><div class="line">        logging.info(<span class="string">"\tparse UV0..."</span>)</div><div class="line">        uvs   = self.fbxMesh.GetLayer(<span class="number">0</span>).GetUVs()</div><div class="line">        data  = uvs.GetDirectArray()</div><div class="line">        polygonCount = self.fbxMesh.GetPolygonCount()</div><div class="line">        vertIdx = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(polygonCount):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">                controlPointIndex = self.fbxMesh.GetPolygonVertex(i, j)</div><div class="line">                <span class="comment"># by point</span></div><div class="line">                <span class="keyword">if</span> uvs.GetMappingMode() == FbxLayerElement.eByControlPoint:</div><div class="line">                    <span class="keyword">if</span> uvs.GetReferenceMode() == FbxLayerElement.eDirect:</div><div class="line">                        uv = data.GetAt(controlPointIndex)</div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">elif</span> uvs.GetReferenceMode() == FbxLayerElement.eIndexToDirect:</div><div class="line">                        idx = uvs.GetIndexArray().GetAt(controlPointIndex)</div><div class="line">                        uv = data.GetAt(idx)</div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">pass</span> <span class="comment"># end if</span></div><div class="line">                <span class="keyword">elif</span> uvs.GetMappingMode() == FbxLayerElement.eByPolygonVertex:</div><div class="line">                    <span class="keyword">if</span> uvs.GetReferenceMode() == FbxLayerElement.eDirect:</div><div class="line">                        uv = data.GetAt(vertIdx)</div><div class="line">                        <span class="keyword">pass</span> <span class="comment">#end</span></div><div class="line">                    <span class="keyword">elif</span> uvs.GetReferenceMode() == FbxLayerElement.eIndexToDirect:</div><div class="line">                        idx = uvs.GetIndexArray().GetAt(vertIdx)</div><div class="line">                        uv = data.GetAt(idx)</div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">pass</span> <span class="comment"># end</span></div><div class="line">                self.uvs0.append([uv[<span class="number">0</span>], <span class="number">1</span> - uv[<span class="number">1</span>]])</div><div class="line">                vertIdx += <span class="number">1</span></div><div class="line">                <span class="keyword">pass</span> <span class="comment"># end for polygon size</span></div><div class="line">            <span class="keyword">pass</span> <span class="comment"># end for polygon count</span></div><div class="line">        logging.info(<span class="string">"\tUV0 num:%d"</span> % (len(self.uvs0)))</div><div class="line">        <span class="comment"># 重构uv0索引顺序</span></div><div class="line">        count = len(self.uvs0)</div><div class="line">        count = count / <span class="number">3</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">            v0 = self.uvs0[i * <span class="number">3</span> + <span class="number">0</span>]</div><div class="line">            v1 = self.uvs0[i * <span class="number">3</span> + <span class="number">1</span>]</div><div class="line">            v2 = self.uvs0[i * <span class="number">3</span> + <span class="number">2</span>]</div><div class="line">            self.uvs0[i * <span class="number">3</span> + <span class="number">0</span>] = v2</div><div class="line">            self.uvs0[i * <span class="number">3</span> + <span class="number">1</span>] = v1</div><div class="line">            self.uvs0[i * <span class="number">3</span> + <span class="number">2</span>] = v0</div><div class="line">            <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end if</span></div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<h3 id="解析uv1">解析uv1</h3>
<p>uv1即第1层的uv数据，这个过程和uv0一样，只是层数不一样而已。一般来说两层uv已经够用了。如果有更多的，大家自己扩展即可。</p>
<h3 id="解析法线">解析法线</h3>
<p>法线的存储格式和uv的存储格式一样。获取方式大同小异。这里我们需要注意的是当获取到法线数据之后，我们需要对法线也进行一个FLIP的操作。FBXAMAtrix没有对矢量进行变换的API。我们需要用到我们之前封装的Matrix3D。里面提供了一个对矢量进行翻转的函数。大家要注意，对矢量的变换与标量的变换是不同的。在前面矩阵变换中提到过。对法线flip完之后，我们最好规格化一次，最后与之前一样，我们需要交互一下位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 解析法线</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseNormals</span><span class="params">(self)</span>:</span></div><div class="line">    logging.info(<span class="string">"\tparse normals..."</span>)</div><div class="line">    normals = self.fbxMesh.GetLayer(<span class="number">0</span>).GetNormals()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> normals:</div><div class="line">        <span class="keyword">return</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    data = normals.GetDirectArray()</div><div class="line">    polygonCount = self.fbxMesh.GetPolygonCount()</div><div class="line">    vertIdx = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(polygonCount):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">            controlPointIndex = self.fbxMesh.GetPolygonVertex(i, j)</div><div class="line">            <span class="comment"># by point</span></div><div class="line">            <span class="keyword">if</span> normals.GetMappingMode() == FbxLayerElement.eByControlPoint:</div><div class="line">                <span class="keyword">if</span> normals.GetReferenceMode() == FbxLayerElement.eDirect:</div><div class="line">                    nrm = data.GetAt(controlPointIndex)</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">elif</span> normals.GetReferenceMode() == FbxLayerElement.eIndexToDirect:</div><div class="line">                    idx = normals.GetIndexArray().GetAt(controlPointIndex)</div><div class="line">                    nrm = data.GetAt(idx)</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">pass</span> <span class="comment"># end if</span></div><div class="line">            <span class="keyword">elif</span> normals.GetMappingMode() == FbxLayerElement.eByPolygonVertex:</div><div class="line">                <span class="keyword">if</span> normals.GetReferenceMode() == FbxLayerElement.eDirect:</div><div class="line">                    nrm = data.GetAt(vertIdx)</div><div class="line">                    <span class="keyword">pass</span> <span class="comment">#end</span></div><div class="line">                <span class="keyword">elif</span> normals.GetReferenceMode() == FbxLayerElement.eIndexToDirect:</div><div class="line">                    idx = normals.GetIndexArray().GetAt(vertIdx)</div><div class="line">                    nrm = data.GetAt(idx)</div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">pass</span> <span class="comment"># end</span></div><div class="line">            self.normals.append(nrm)</div><div class="line">            vertIdx += <span class="number">1</span></div><div class="line">            <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">    </div><div class="line">    <span class="comment"># 对法线进行转换</span></div><div class="line">    count = len(self.normals)</div><div class="line">    axis  = Matrix3D(self.axisTransform)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">        nrm = self.normals[i]</div><div class="line">        nrm = axis.deltaTransformVector(nrm)</div><div class="line">        nrm = FbxVector4(nrm[<span class="number">0</span>], nrm[<span class="number">1</span>], nrm[<span class="number">2</span>], <span class="number">1</span>)</div><div class="line">        nrm.Normalize()</div><div class="line">        self.normals[i] = [nrm[<span class="number">0</span>], nrm[<span class="number">1</span>], nrm[<span class="number">2</span>]]</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">    <span class="comment"># 重构法线索引顺序</span></div><div class="line">    count = count / <span class="number">3</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">        v0 = self.normals[i * <span class="number">3</span> + <span class="number">0</span>]</div><div class="line">        v1 = self.normals[i * <span class="number">3</span> + <span class="number">1</span>]</div><div class="line">        v2 = self.normals[i * <span class="number">3</span> + <span class="number">2</span>]</div><div class="line">        self.normals[i * <span class="number">3</span> + <span class="number">0</span>] = v2</div><div class="line">        self.normals[i * <span class="number">3</span> + <span class="number">1</span>] = v1</div><div class="line">        self.normals[i * <span class="number">3</span> + <span class="number">2</span>] = v0</div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end for</span></div><div class="line">    <span class="keyword">pass</span> <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<h3 id="解析切线">解析切线</h3>
<p>切线主要是用来做NormalMap等等贴图法线的效果。目的使用贴图的数据来替换掉模型本身的法线数据。切线是需要法线和uv一起结算出来。因此我们在计算切线之前要保证UV和法线一定存在。切线与法线一样，也是标量，我们需要用Matrix3D来对它进行flip操作。最后与之前一样，我们需要交互一下位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"></span></div><div class="line"># 解析切线</div><div class="line">def parseTangent(<span class="variable">self</span>):  </div><div class="line">    logging.info(<span class="string">"\tparse tangents..."</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> config.normal:</div><div class="line">        <span class="variable">self</span>.parseNormals()</div><div class="line">        pass<span class="preprocessor"></span></div><div class="line">    # 计算切线</div><div class="line">    <span class="variable">self</span>.fbxMesh.GenerateTangentsDataForAllUVSets()</div><div class="line">    tangents = <span class="variable">self</span>.fbxMesh.GetLayer(<span class="number">0</span>).GetTangents()</div><div class="line">    count    = tangents.GetDirectArray().GetCount()</div><div class="line">    data     = tangents.GetDirectArray()</div><div class="line">    logging.info(<span class="string">"\ttangent num:%d"</span> % count)</div><div class="line">    <span class="keyword">for</span> i in range(count):</div><div class="line">        <span class="variable">self</span>.tangents.append(data.GetAt(i))</div><div class="line">        pass<span class="preprocessor"></span></div><div class="line">    # 对切线进行转换</div><div class="line">    count = len(<span class="variable">self</span>.tangents)</div><div class="line">    axis  = Matrix3D(<span class="variable">self</span>.axisTransform)</div><div class="line">    <span class="keyword">for</span> i in range(count):</div><div class="line">        <span class="built_in">tan</span> = <span class="variable">self</span>.tangents[i]</div><div class="line">        <span class="built_in">tan</span> = axis.deltaTransformVector(<span class="built_in">tan</span>)</div><div class="line">        <span class="built_in">tan</span> = FbxVector4(<span class="built_in">tan</span>[<span class="number">0</span>], <span class="built_in">tan</span>[<span class="number">1</span>], <span class="built_in">tan</span>[<span class="number">2</span>], <span class="number">1</span>)</div><div class="line">        <span class="built_in">tan</span>.Normalize()</div><div class="line">        <span class="variable">self</span>.tangents[i] = [<span class="built_in">tan</span>[<span class="number">0</span>], <span class="built_in">tan</span>[<span class="number">1</span>], <span class="built_in">tan</span>[<span class="number">2</span>]]</div><div class="line">        pass<span class="preprocessor"> # <span class="keyword">end</span> for</span><span class="preprocessor"></span></div><div class="line">    # 重构切线索引顺序</div><div class="line">    count = count / <span class="number">3</span></div><div class="line">    <span class="keyword">for</span> i in range(count):</div><div class="line">        v0 = <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">0</span>]</div><div class="line">        v1 = <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">1</span>]</div><div class="line">        v2 = <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">2</span>]</div><div class="line">        <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">0</span>] = v2</div><div class="line">        <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">1</span>] = v1</div><div class="line">        <span class="variable">self</span>.tangents[i * <span class="number">3</span> + <span class="number">2</span>] = v0</div><div class="line">        pass<span class="preprocessor"> # <span class="keyword">end</span> for</span></div><div class="line">    pass<span class="preprocessor"> # <span class="keyword">end</span> func</span></div></pre></td></tr></table></figure>

<h3 id="动画的解析放到后面">动画的解析放到后面</h3>
<h3 id="解析材质">解析材质</h3>
<p>材质的解析我做得十分简单，没有解析在里面的灯光信息等等。我只是简单的获取了贴图的名称。因为在stage3d中，一个场景基本上是不可能打灯光或者一般只打了一个灯光。因此这个效果需要根据项目的需求在程序中添加。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 解析材质，只解析第一层材质</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parseMaterial</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"\tparse materials..."</span>)</div><div class="line">        count = self.fbxMesh.GetNode().GetMaterialCount()</div><div class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        self.material = Material()</div><div class="line">        self.material.initWithFbxMaterial(self.fbxMesh.GetNode().GetMaterial(<span class="number">0</span>))</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 材质</span></div><div class="line"><span class="comment"># 只会解析最基础的材质</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span><span class="params">(object)</span>:</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(Material, self).__init__()</div><div class="line">        </div><div class="line">        self.material       = <span class="keyword">None</span>      <span class="comment"># 材质</span></div><div class="line">        self.name           = <span class="keyword">None</span>      <span class="comment"># 材质名称</span></div><div class="line">        self.textures       = {}        <span class="comment"># 所有的贴图</span></div><div class="line">        </div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line">    </div><div class="line">    <span class="comment"># 初始化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initWithFbxMaterial</span><span class="params">(self, material)</span>:</span></div><div class="line">        self.material = material</div><div class="line">        self.name     = self.material.GetName() </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(FbxLayerElement.sTypeTextureCount()):</div><div class="line">            prop = self.material.FindProperty(FbxLayerElement.sTextureChannelNames(i))</div><div class="line">            count = prop.GetSrcObjectCount(FbxTexture.ClassId)</div><div class="line">            typeName = str(prop.GetName())</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(count):</div><div class="line">                texture = prop.GetSrcObject(FbxTexture.ClassId, j)</div><div class="line">                texName = re.compile(<span class="string">"[\\\/]"</span>).split(texture.GetFileName())[-<span class="number">1</span>]</div><div class="line">                texName = texName.replace(<span class="string">".dds"</span>, <span class="string">".png"</span>)</div><div class="line">                texName = texName.replace(<span class="string">".tga"</span>, <span class="string">".png"</span>)</div><div class="line">                self.textures[typeName] = texName</div><div class="line">                logging.info(<span class="string">"\t%s -&gt; %s"</span> % (prop.GetName(), self.textures[typeName]))</div><div class="line">                <span class="keyword">pass</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">pass</span> <span class="comment"># end func</span></div><div class="line">        </div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>

<h3 id="模型的拆分与动画一起放到后面">模型的拆分与动画一起放到后面</h3>
<p>这里提一下。在stage3d中，为了兼容各个平台，因此上传到gpu的数据是限制了的。每一个VertexBuffer只能上传65535个顶点数据。因此不管是静态模型还是动画我们都需要有一个拆分的功能。不然碰到十多万顶点一个的模型，我们就无能为力了。</p>
<h3 id="模型数据的生成">模型数据的生成</h3>
<p>得到所有的模型数据之后，我们将模型数据打包成二进制。并且压缩。我们不存储索引数据。因此索引数据已经没有意义。我们在程序中生成对应的索引数据即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成模型数据</span></div><div class="line">def generateMeshBytes(self):</div><div class="line">    <span class="comment"># 生成Mesh对应的文件名称</span></div><div class="line">    tokens  = re.compile(<span class="string">"[\\\/]"</span>).<span class="built_in">split</span>(self.fbxFilePath)</div><div class="line">    fbxName = tokens[-<span class="number">1</span>]</div><div class="line">    fbxName = fbxName.<span class="built_in">split</span>(<span class="string">"."</span>)[<span class="number">0</span>:-<span class="number">1</span>]</div><div class="line">    fbxName = <span class="string">"."</span>.join(fbxName)</div><div class="line">    fbxDir  = parseFilepath(self.fbxFilePath)</div><div class="line">    self.meshFileName = fbxDir + fbxName + <span class="string">"_"</span> + self.name + MESH_TYPE</div><div class="line">    <span class="comment"># 组织Mesh数据</span></div><div class="line">    data = b<span class="string">''</span></div><div class="line">    <span class="comment"># 写名称</span></div><div class="line">    data += struct.pack(<span class="string">'&lt;i'</span>, <span class="built_in">len</span>(self.name)) </div><div class="line">    data += str(self.name)</div><div class="line">    <span class="comment"># 写坐标</span></div><div class="line">    data += getMatrix3DBytes(self.transform)</div><div class="line">    <span class="comment"># 写SubMesh数量</span></div><div class="line">    subNum = <span class="built_in">len</span>(self.geometries)</div><div class="line">    data  += struct.pack(<span class="string">"&lt;i"</span>, subNum)</div><div class="line">    <span class="comment"># 写数据</span></div><div class="line">    <span class="keyword">for</span> subIdx <span class="operator">in</span> range(subNum):</div><div class="line">        subMesh = self.geometries[subIdx]</div><div class="line">        <span class="comment"># 写顶点</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.vertices)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)            </div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):                     </div><div class="line">            vert = subMesh.vertices[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;fff'</span>, vert[<span class="number">0</span>], vert[<span class="number">1</span>], vert[<span class="number">2</span>])</div><div class="line">            pass <span class="comment"># end for</span></div><div class="line">        <span class="comment"># 写UV0</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.uvs0)                      </div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            uv = subMesh.uvs0[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;ff'</span>, uv[<span class="number">0</span>], uv[<span class="number">1</span>])</div><div class="line">            pass <span class="comment"># end for</span></div><div class="line">        <span class="comment"># 写UV1</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.uvs1)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            uv = subMesh.uvs1[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;ff'</span>, uv[<span class="number">0</span>], uv[<span class="number">1</span>])</div><div class="line">            pass <span class="comment"># end for </span></div><div class="line">        <span class="comment"># 写法线</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.normals)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            <span class="keyword">normal</span> = subMesh.normals[i]</div><div class="line">            data  += struct.pack(<span class="string">'&lt;fff'</span>, <span class="keyword">normal</span>[<span class="number">0</span>], <span class="keyword">normal</span>[<span class="number">1</span>], <span class="keyword">normal</span>[<span class="number">2</span>])</div><div class="line">            pass</div><div class="line">        count = <span class="built_in">len</span>(subMesh.tangents)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            <span class="built_in">tan</span>   = subMesh.tangents[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;fff'</span>, <span class="built_in">tan</span>[<span class="number">0</span>], <span class="built_in">tan</span>[<span class="number">1</span>], <span class="built_in">tan</span>[<span class="number">2</span>])</div><div class="line">            pass</div><div class="line">        <span class="comment"># 写权重数据</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.weightsAndIndices)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            weIdx = subMesh.weightsAndIndices[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;ffff'</span>, weIdx[<span class="number">0</span>], weIdx[<span class="number">1</span>], weIdx[<span class="number">2</span>], weIdx[<span class="number">3</span>])</div><div class="line">            pass <span class="comment"># end</span></div><div class="line">        count = <span class="built_in">len</span>(subMesh.weightsAndIndices)</div><div class="line">        data += struct.pack(<span class="string">'&lt;i'</span>, count)</div><div class="line">        </div><div class="line">        step = <span class="number">3</span></div><div class="line">        <span class="keyword">if</span> config.quat:</div><div class="line">            step = <span class="number">2</span></div><div class="line">            pass</div><div class="line">        <span class="comment"># 写骨骼索引数据</span></div><div class="line">        <span class="keyword">for</span> i <span class="operator">in</span> range(count):</div><div class="line">            weIdx = subMesh.weightsAndIndices[i]</div><div class="line">            data += struct.pack(<span class="string">'&lt;ffff'</span>, weIdx[<span class="number">4</span>] * step, weIdx[<span class="number">5</span>] * step, weIdx[<span class="number">6</span>] * step, weIdx[<span class="number">7</span>] * step)</div><div class="line">            pass</div><div class="line">        </div><div class="line">        pass <span class="comment"># end for</span></div><div class="line">    </div><div class="line">    <span class="comment"># 写包围盒数据</span></div><div class="line">    data += struct.pack(<span class="string">'&lt;ffffff'</span>, self.bounds.<span class="built_in">min</span>[<span class="number">0</span>], self.bounds.<span class="built_in">min</span>[<span class="number">1</span>], self.bounds.<span class="built_in">min</span>[<span class="number">2</span>], self.bounds.<span class="built_in">max</span>[<span class="number">0</span>], self.bounds.<span class="built_in">max</span>[<span class="number">1</span>], self.bounds.<span class="built_in">max</span>[<span class="number">2</span>])</div><div class="line">    <span class="comment"># 压缩</span></div><div class="line">    data = zlib.<span class="built_in">compress</span>(data, <span class="number">9</span>)</div><div class="line">    </div><div class="line">    self.meshBytes = data</div><div class="line">    pass <span class="comment"># end func</span></div></pre></td></tr></table></figure>

<p>生成完数据之后，我们存储到磁盘即可。在这里我使用的是小头二进制格式。因此在gpu中要求的数据也是属于小头。在stage3d中VertexBuffer上传数据提供了两种方式，一种上传Vector.<number>类型，另一种则是上传二进制。经过我自己以及其它老外的测试，发现二进制上传会快速一些。由于我们在解析的过程中已经对数据格式进行了处理，在as3中，我们只需要读入二进制内容，获取对应的数据块，上传至显卡即可。这样我们就省掉了解析文本、数据组织等的一系列得操作。关于上传速度的测试请戳这里，可能需要翻墙:<a href="http://jacksondunstan.com/articles/1617" target="_blank" rel="external">戳这里</a>。最后我们在程序中解析也会变成非常简单。在as3读取代码戳这里。<a href="https://github.com/BobLChen/Monkey/blob/master/Monkey/src/monkey/core/utils/Mesh3DUtils.as" target="_blank" rel="external">戳这里</a></number></p>
<!-- <iframe src="http://boblchen.github.io/samples/stage3d_16_%E9%AA%A8%E9%AA%BC/1/MonkeyWeb.html" width="800" height="600" frameborder="0" allowfullscreen></iframe> --><br><!-- <img src="/images/stage3d_16_骨骼/814D57C2-3024-47AD-90A0-71F29A7F3918.png" class="[class names]"> -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/15/stage3d-17-fbx解析/" data-id="vakz0ekrlevz2swf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/02/28/stage3d-16-骨骼动画/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">stage3d_16_骨骼动画</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D/">3D</a><span class="category-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3D/">3D</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FLash3D/">FLash3D</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stage3D/">Stage3D</a><span class="tag-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/3D/" style="font-size: NaNpx;">3D</a><a href="/tags/FLash3D/" style="font-size: NaNpx;">FLash3D</a><a href="/tags/Stage3D/" style="font-size: NaNpx;">Stage3D</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/15/stage3d-17-fbx解析/">stage3d_17_fbx解析</a>
          </li>
        
          <li>
            <a href="/2015/02/28/stage3d-16-骨骼动画/">stage3d_16_骨骼动画</a>
          </li>
        
          <li>
            <a href="/2015/02/12/stage3d-15-灯光/">stage3d_15_平行光</a>
          </li>
        
          <li>
            <a href="/2015/02/09/stage3d-14-深度混合代码/">stage3d_14_裁减以及shader代码</a>
          </li>
        
          <li>
            <a href="/2015/02/05/stage3d-13-法线/">stage3d_13_法线以及光照</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 小朋友 QQ:470259651<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>